# 二、逻辑代数基础

## 1. 概述：

逻辑：因（输入）果（输出）关系

二值逻辑：数字电路表达信息由数字信号表示（0，1），且勇于表达两种对立状态，只有两个取值。

逻辑变量（表达输入的条件）：A，B，C（取值范围：要么为0，要么为1，这也是与其他变量不同的地方）

逻辑运算：反映逻辑变量运算关系，也可以理解为就是将因果关系组合。

## 2. 基本逻辑运算

### （1）与运算：

+ 真值表（将输入输出全部列出并将结果计算出）

  | A    | B    | Y    |
  | ---- | ---- | ---- |
  | 0    | 0    | 0    |
  | 0    | 1    | 0    |
  | 1    | 0    | 0    |
  | 1    | 1    | 1    |



+ 电路图：

  只有两个开关状态均为合上（1）的时候，灯才会亮（1）。

  开关是“因”，灯的亮灭为“果”。

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \begin{document}
      \begin{tikzpicture}[european]
          \draw (0,0) to[battery] ++(0,2)
          to[closing switch=A, n=S2] ++(2,0)
          to[closing switch=B, n=S2] ++(2,0)
          to[D=LED] ++(0, -2)
          to[short] ++(-4, 0);
      \end{tikzpicture}
  \end{document}
  ```

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-1-AND.png" alt="与电路" style="zoom:50%;" />

+ 描述：

  当输入变量中有一个取值为0，则输出结果为0。

  当输入变量全为1的时候，输出结果为1。

+ 逻辑表达式：

  Y = A · B （与逻辑乘法的运算关系类似）

  还可以有三个条件变量（A，B，C），逻辑表达式为：Y =A · B · C

+ 数字电路中的符号表达：

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[and port] (and1) {};
          \draw let \p1=(and1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1=(and1.in 2) in (\x1, \y1) node[left] {B};
          \draw let \p1=(and1.out) in (\x1, \y1) node[right] {Y};
      \end{circuitikz}
  \end{document}
  ```

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-2-AND_ANSI.png" alt="AND_ANSI" style="zoom:50%;" />

  上述为ieee标准的与门电路符号

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-3-IEC_AND.png" alt="IEC_AND" style="zoom:50%;" />

  上述为iec标准的与门电路符号

### （2）或运算

+ 真值表：（将输入输出全部列出并将结果计算出）

  | A    | B    | Y    |
  | ---- | ---- | ---- |
  | 0    | 0    | 0    |
  | 0    | 1    | 1    |
  | 1    | 0    | 1    |
  | 1    | 1    | 1    |

+ 电路图：

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 1,
  }   
  \begin{document}
      \begin{circuitikz}[european]
          \draw (0,0) to[battery] ++(0,2)
          to[closing switch=A, n=S2] ++(4,0)
          to[D=LED] ++(0, -2)
          to[closing switch=B, n=S2] ++(-4,0);
      \end{circuitikz}
  \end{document}
  ```

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-4-OR.png" alt="或门电路" style="zoom:50%;" />

+ 描述：

  只要有一个条件满足，就可以得到1。

  只有两个条件均不满足的时候，才为0。

+ 逻辑表达式（逻辑加）：

  Y = A + B

+ 数字电路中的符号表达：

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[or port] (or1) {};
          \draw let \p1=(or1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1=(or1.in 2) in (\x1, \y1) node[left] {B};
          \draw let \p1=(or1.out) in (\x1, \y1) node[right] {Y};
      \end{circuitikz}
  \end{document}
  

​											<img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-5-OR_ANSI.png" alt="OR_ANSI" style="zoom:50%;" />

​	上述为ieee标准的或门电路符号

​											<img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-6-IEC_OR.png" alt="IEC_OR" style="zoom:50%;" />

​	上述为国际标准（iec）符号

### （3）非运算

+ 真值表：（将输入输出全部列出并将结果计算出）

  | A    | Y    |
  | ---- | ---- |
  | 0    | 1    |
  | 1    | 0    |

+ 描述：

  输入信号只能有一个

+ 逻辑表达式：

  $ Y = \overline A = A ^ {\prime} $

+ 数字电路中的符号表达（非门 == 相反器）

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[not port, anchor=out] (not1) {};
          \draw let \p1=(not1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1=(not1.out) in (\x1, \y1) node[right] {Y};
      \end{circuitikz}
  \end{document}
  ```

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-7-NOT_ANSI.png" alt="NOT_ANSI" style="zoom:50%;" />

  上述为ieee标准的非门（相反器）电路符号

​													<img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-8-IEC_NOT.png" alt="IEC_NOT" style="zoom:50%;" />

​	上述为国际标准符号（iec）

### （4） 异或运算

+ 真值表

  | A    | B    | Y    |
  | ---- | ---- | ---- |
  | 0    | 0    | 0    |
  | 0    | 1    | 1    |
  | 1    | 0    | 1    |
  | 1    | 1    | 0    |

+ 描述：

  当输入的两个信号相同的时候输出为0；

  当输入的两个信号不同的时候输出为1

  可以接纳的输入信号只有两个，如果要接受三输入的，必须使用两个

+ 逻辑表达式：

  $ Y = A \oplus B = A ^ {\prime} B + A B ^ {\prime} = \overline {A} B + A \overline {B} $ 

+ 数字电路符号表达：

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[xor port, anchor=out] (xor1) {};
          \draw let \p1 = (xor1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1 = (xor1.in 2) in (\x1, \y1) node[left] {B};
          \draw let \p1 = (xor1.out) in (\x1, \y1) node[right] {Y};
      \end{circuitikz}
  \end{document}
  ```

​													<img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-15-XOR_ANSI.png" alt="DGCR-2-15-XOR_ANSI" style="zoom:50%;" />

​	上述为ieee标准

​													<img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-16-IEC_XOR.png" alt="DGCR-2-16-IEC_XOR" style="zoom:50%;" />

​	上述为国际标准（iec）

### （5）同或运算

+ 真值表

  | A    | B    | Y    |
  | ---- | ---- | ---- |
  | 0    | 0    | 1    |
  | 0    | 1    | 1    |
  | 1    | 0    | 1    |
  | 1    | 1    | 0    |

+ 描述：

  当输入的两个信号相同的时候输出为1

  当输入的两个信号不同的时候输出为0

  可以接纳的输入信号只有两个，如果要接受三输入的，必须使用两个

+ 逻辑表达式：

  $ Y = A \bigodot B = A ^ {\prime} B ^ {\prime} + A B = \overline {A} \overline {B} + A B $

+ 数字电路符号表达：

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[xnor port, anchor=out] (xnor1) {};
          \draw let \p1 = (xnor1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1 = (xnor1.in 2) in (\x1, \y1) node[left] {B};
          \draw let \p1 = (xnor1.out) in (\x1, \y1) node[right] {Y};
      \end{circuitikz}
  \end{document}
  ```

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-17-XNOR_ANSI.png" alt="DGCR-2-17-XNOR_ANSI" style="zoom:50%;" />

  上述为ieee标准

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-18-IEC_XNOR.png" alt="DGCR-2-18-IEC_XNOR" style="zoom:50%;" />

  上述为国际标准（iec）

## 3. 复合逻辑运算

### （1） 与非运算

+ 真值表：

  | A    | B    | Y    |
  | ---- | ---- | ---- |
  | 0    | 0    | 1    |
  | 0    | 1    | 1    |
  | 1    | 0    | 1    |
  | 1    | 1    | 0    |

+ 描述：

  与的运算结束后，对结果取反。

  其中有一个逻辑变量取值为0，结果为1.

  只有全部逻辑变量取值为1， 结果为0.

+ 逻辑表达式：

  $ Y = (A · B) ^ {\prime} = \overline {AB} $

+ 数字电路符号表达

  ``````latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[nand port, anchor=out] (nand1) {};
          \draw let \p1=(nand1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1=(nand1.in 2) in (\x1, \y1) node[left] {B};
          \draw let \p1=(nand1.out) in (\x1, \y1) node[right] {Y};
      \end{circuitikz}
  \end{document}
  ``````

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-9-NAND_ANSI.png" alt="NAND_ANSI" style="zoom:50%;" />

​	上述为ieee标准表示的电路符号

​													<img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-10-IEC_NAND.png" alt="DGCR-2-10-IEC_NAND.png" style="zoom:50%;" />

​	上述为国际标准符号（iec）

### （2） 或非运算

+ 真值表

  | A    | B    | Y    |
  | ---- | ---- | ---- |
  | 0    | 0    | 1    |
  | 0    | 1    | 0    |
  | 1    | 0    | 0    |
  | 1    | 1    | 0    |

+ 描述

  其中一个输入信号（逻辑变量）中有一个取值为1，结果为0。

  只有所有输入信号取值为0， 结果为1.

+ 逻辑表达式：

  $ Y = (A + B) ^ {\prime} = \overline {A + B} $

+ 数字电路中的符号表达

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[nor port, anchor=out] (nor1) {};
          \draw let \p1=(nor1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1=(nor1.in 2) in (\x1, \y1) node[left] {B};
          \draw let \p1=(nor1.out) in (\x1, \y1) node[right] {Y};
      \end{circuitikz}
  \end{document}
  ```

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-11-NOR_ANSI.png" alt="DGCR-2-11-NOR_ANSI" style="zoom:50%;" />

  上述为ieee标准

​													<img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-12-IEC_NOR.png" alt="DGCR-2-12-IEC_NOR" style="zoom:50%;" />

​	上述为国际标准

### （4）与或非运算

+ 真值表：

  | A    | B    | C    | D    | Y    |
  | ---- | ---- | ---- | ---- | ---- |
  | 0    | 0    | 0    | 0    | 1    |
  | 0    | 0    | 0    | 1    | 1    |
  | 0    | 0    | 1    | 0    | 1    |
  | 0    | 0    | 1    | 1    | 0    |
  | 0    | 1    | 0    | 0    | 1    |
  | 0    | 1    | 0    | 1    | 1    |
  | 0    | 1    | 1    | 0    | 1    |
  | 0    | 1    | 1    | 1    | 0    |
  | 1    | 0    | 0    | 0    | 1    |
  | 1    | 0    | 0    | 1    | 1    |
  | 1    | 0    | 1    | 0    | 1    |
  | 1    | 0    | 1    | 1    | 0    |
  | 1    | 1    | 0    | 0    | 0    |
  | 1    | 1    | 0    | 1    | 0    |
  | 1    | 1    | 1    | 0    | 0    |
  | 1    | 1    | 1    | 1    | 0    |

+ 逻辑表达式：

  $ Y = (AB + CD) ^ {\prime} = \overline {AB + CD} $

+ 数字电路图：

  ```latex
  \documentclass{article}
  \usepackage{circuitikz}
  
  \ctikzset{
      logic ports = ieee,
      logic ports/scale = 0.7,
  }   
  \begin{document}
      \begin{circuitikz}[]
          \draw (3,3) node[and port] (and2) {};
          \draw (6,4) node[nor port, anchor=out] (or1) {};
          \draw (3,5) node[and port] (and1) {};
          \draw let \p1 = (and1.in 1) in (\x1, \y1) node[left] {A};
          \draw let \p1 = (and1.in 2) in (\x1, \y1) node[left] {B};
          \draw let \p1 = (and2.in 1) in (\x1, \y1) node[left] {C};
          \draw let \p1 = (and2.in 2) in (\x1, \y1) node[left] {D};
          \draw let \p1 = (or1.out) in (\x1, \y1) node[right] {Y};
          \draw (and1.out) -| (or1.in 1);
          \draw (and2.out) -| (or1.in 2);
      \end{circuitikz}
  \end{document}
  ```

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-13-AND_NOR_ANSI.png" alt="AND_NOR_ANSI" style="zoom:50%;" />

  上述为ieee标准

  <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-14-IEC_AND_NOR.png" alt="IEC_AND_NOR" style="zoom:50%;" />

  上述为国际标准（iec）

## 4. 逻辑代数的基本公式和常用公式

#### （1） 基本公式

+ 与运算基本公式：

1. $ 0 · A = 0 $
2. $ 1 · A = A $
3. $ A · A = A $ 
4. $ A · A ^ {\prime} = 0 $ （互补律）
5. $ A · B = B · A $
6. $ A · ( B · C ) = ( A · B ) · C $
7. $ A · ( B + C ) = A · B + A · C $
8. $ ( A · B ) ^ {\prime} = A ^ {\prime} + B ^ {\prime} $ （摩根定理 = 反演律）
9. $ ( A ^ {\prime} ) ^ {\prime} = A $ （双重否定）

+ 或运算的基本公式：

1. $ 1 ^ {\prime} = 0; 0 ^ {\prime} = 1$
2. $ 1 + A = 1$ 
3. $ 0 + A = A $
4. $ A + A = A $
5. $ A + A ^ {\prime} = 1 $ （互补律）
6. $ A + B = B + A $
7. $ A + ( B + C ) = ( A + B ) + C $
8. $ A + B · C = ( A + B ) · ( A + C ) $
9. $ ( A + B ) ^ {\prime} = A ^ {\prime} · B ^ {\prime} $ （摩根定理 = 反演律）

+ 证明方式：真值表或者逻辑函数表达方式，逻辑函数表达方式可能不是唯一的，是多样的，但是真值表一定是相同的。

### （2） 常用公式

+ 对基本公式进行了组合。

+ 常用公式：

  1. $ A + A · B = A $

  2. $$
     \begin{align*}
     A + A ^ {\prime} · B &= A · ( 1 + B ) + A ^ {\prime} · B \\
     										 &= A + A · B + A ^ {\prime} · B \\
     										 &= A + B · ( A + A ^ {\prime} ) \\
     										 &= A + B
     \end{align*}
     $$

  3. $ A · B + A  · B ^ {\prime} = A $

  4. $ A · ( A + B ) = A $

  5. $$
     \begin{align*}
     A · B + A ^ {\prime} · C + B · C &= A · B + A ^ {\prime} · C + B · C ·( A + A ^ {\prime}) \\
     																 &= A · B + A ^ {\prime} · C + A · B · C + A ^ {\prime} · B · C \\
     																 &= A · B · ( 1 + C ) + A ^ {\prime} · C · (1 + B) \\
     																 &= A · B + A ^ {\prime} · C 
     \end{align*}
     $$

     ;
     $$
     \begin{align*}
     A · B + A ^ {\prime} · C + BCD &= A · B + A ^ {\prime} · C + B · C · D + B · C \\
     															 &= A · B + A ^ {\prime} · C + B · C · (1 + D) \\
     															 &= A · B + A ^ {\prime} · C + B · C \\
     															 &= A · B + A ^ {\prime} · C
     \end{align*}
     $$

  6. $ A · ( A · B ) ^ {\prime} = A · B ^ {\prime}; A ^ {\prime} · ( AB ) ^ {\prime} = A ^ {\prime} $

### （3） 基本定理

+ 代入定理：
  + 描述：在任何一个包含变量A的逻辑等式中，若以另外一个逻辑式代入式中所有A的位置，则等式仍然成立。
+ 反演定理：
  + 目的：就是为了求反函数。在实际电路处理当中，二值逻辑是通过电压表示，正常逻辑来说，1代表高电平，总是让电路工作，但是实际应用中，有很多低电平工作的情况，这个时候反函数就非常重要。
  + 描述：对于任意一个逻辑式，如果将其中所有的“与运算”换成“或运算”，“或运算”换成“与运算”，0换成1，1换成0，原变量换成反变量，反变量换成原变量，则得到的结果就是$Y ^ {\prime}$。
  + 注意遵循两个规则：
    1. 仍需遵守“先括号、然后乘、最后加”的运算优先次序。
    2. 不属于单个变量上的反号应保留不变。
+ 对偶定理：
  + 目的：求对偶式，往往用来证明两个等式是否相同。
  + 描述：对于任何一个逻辑式Y，若将其中的“与运算”换成“或运算”，”或运算“换成”与运算“，0换成1，1换成0，则得到一个新的逻辑式$ Y ^ D$。

## 5. 逻辑函数及其描述方法

### （1）逻辑函数

$ Y = F( A, B, C, ···) $

所有涉及到的变量均为逻辑变量，而且这些逻辑变量都是二值逻辑，只有0，1。

### （2）逻辑函数的表达方法

+ 逻辑真值表
  + 定义：将输入变量所有的取值下对应的输出值找出来，列成表格，即可得到真值表。

+ 逻辑函数表达式

  + 定义：将输出与输入之间的逻辑关系写成与、或、非等运算的组合式，即逻辑代数式，就得到了所需的逻辑函数式。
  + 例子：$ Y = AB + CD$
+ 逻辑图/逻辑电路图

  + 定义：将逻辑函数式中各变量之间的与、或、非等了偶寄关系用图形符号表示出来，就可以画出描述函数关系的逻辑图。
  + 例子：$ Y = AB + CD$

    通过图像表达：

    ```latex
    \documentclass{article}
    \usepackage{circuitikz}
    
    \ctikzset{
        logic ports = ieee,
        logic ports/scale = 0.7,
    }   
    \begin{document}
        \begin{circuitikz}[]
            \draw (3,3) node[and port, anchor=out] (and1) {};
            \draw (3,5) node[and port, anchor=out] (and2) {};
            \draw (5,4) node[or port, anchor=out] (or1) {};
            \draw let \p1 = (and1.in 1) in (\x1, \y1) node[left] {C};
            \draw let \p1 = (and1.in 2) in (\x1, \y1) node[left] {D};
            \draw let \p1 = (and2.in 1) in (\x1, \y1) node[left] {A};
            \draw let \p1 = (and2.in 2) in (\x1, \y1) node[left] {B};
            \draw let \p1 = (or1.out) in (\x1,\y1) node[right] {Y};
            \draw (and1.out) -| (or1.in 2);
            \draw (and2.out) -| (or1.in 1);
        \end{circuitikz}
    \end{document}
    ```

    <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-19-LOGIC_dia.png" alt="logic diagram" style="zoom:50%;" />
+ 波形图

  + 反映输入输出之间波形时序的关系。
+ 卡诺图
+ 硬件描述语言

### （3） 各种描述方法间的相互转换

+ 真值表与逻辑函数式之间的转换

  + 真值表  ==> 逻辑函数式

    + 方法：

      1. 找出真值表中使逻辑函数$Y = 1$的耐饿输入变量取值的组合。
      2. 每组输入变量取值的组合对应一个乘积项，其中取值为1的写入原变量，取值为0的写入反变量。
      3. 将这些乘积项相加，即得Y的逻辑函数式。

    + 例子：

      | A    | B    | Y    |
      | ---- | ---- | ---- |
      | 0    | 0    | 0    |
      | 0    | 1    | 1    |
      | 1    | 0    | 1    |
      | 1    | 1    | 0    |

      找出其中Y=1时的表达组合，$ Y = A ^ {\prime} B $，$ Y = A B ^ {\prime} $

      再将这些乘积项相加，得到逻辑函数式：$ Y = A ^ {\prime} B + A B ^ {\prime} $

  + 逻辑函数式 ==> 真值表

    + 方法：只需将输入变量取值的所有组合状态逐一代入逻辑式求出函数值，列成表格，即可得到真值表。

    + 例子：

      逻辑函数式：$ Y = AB + C $

      可以得到真值表如下：

      | A    | B    | C    | Y    |
      | ---- | ---- | ---- | ---- |
      | 0    | 0    | 0    | 0    |
      | 0    | 0    | 1    | 1    |
      | 0    | 1    | 0    | 0    |
      | 0    | 1    | 1    | 1    |
      | 1    | 0    | 0    | 0    |
      | 1    | 0    | 1    | 1    |
      | 1    | 1    | 0    | 1    |
      | 1    | 1    | 1    | 1    |

+ 逻辑函数式与逻辑图的互相转换

  + 逻辑函数式 ==> 逻辑图

    + 方法：只要用逻辑图形符号代替逻辑函数式中的逻辑运算符号并按运算优先顺序将它们连接起来，就可以得到所求的逻辑图了。

    + 例子：

      逻辑函数式：$ Y = AB + C $

      逻辑图：

      ```latex
      \documentclass{article}
      \usepackage{circuitikz}
      
      \ctikzset{
          logic ports = ieee,
          logic ports/scale = 0.7,
      }   
      \begin{document}
          \begin{circuitikz}[]
              \draw (3,5) node[and port, anchor=out] (and1) {};
              \draw (5,3) node[or port, anchor=out] (or1) {};
              \draw let \p1 = (and1.in 1) in (\x1, \y1) node[left] {A};
              \draw let \p1 = (and1.in 2) in (\x1, \y1) node[left] {B};
              \draw let \p1 = (or1.in 2) in (\x1, \y1) -- ++(-2,0) node[left] {C};
              \draw let \p1 = (or1.out) in (\x1,\y1) node[right] {Y};
              \draw (and1.out) -| (or1.in 1);
          \end{circuitikz}
      \end{document}
      ```

      <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-20-CONVERT_1.png" alt="DGCR-2-20-CONVERT_1.png" style="zoom:50%;" />

  + 逻辑图 ==> 逻辑函数式

    + 方法：只要从逻辑图的输入端到输出端逐级写出每个图形符号的输出逻辑式，就可以在输出端得到所求的逻辑函数式。

    + 例子：

      逻辑图：

      ```latex
      \documentclass{article}
      \usepackage{circuitikz}
      
      \ctikzset{
          logic ports = ieee,
          logic ports/scale = 1,
      }   
      \begin{document}
          \begin{circuitikz}[european]
              \draw (3,5) node[not port, anchor=out] (not1) {};
              \draw (3,3) node[not port, anchor=out] (not2) {};
              \draw let \p1 = (not1.in) in (\x1, \y1) -- ++(-0.5, 0) node[left] {A};
              \draw let \p1 = (not2.in) in (\x1, \y1) -- ++(-0.5, 0) node[left] {B};
              \draw (6,5) node[nand port, anchor=out] (nand1) {};
              \draw (6,3) node[nand port, anchor=out] (nand2) {};
              \draw (not1.out) |- (nand1.in 1);
              \draw (not2.out) |- (nand2.in 2);
              \draw let \p1 = (not1.in) in (\x1, \y1) -- (\x1, {\y1 - 0.8cm}) -- ({\x1 + 2cm}, {\y1 - 0.8cm}) -- (nand2.in 1);
              \draw let \p1 = (not2.in) in (\x1, \y1) -- (\x1, {\y1 + 0.8cm}) -- ({\x1 + 2cm}, {\y1 + 0.8cm}) -- (nand1.in 2);
              \draw (9,4) node[nand port, anchor=out] (nand3) {};
              \draw (nand1.out) -| (nand3.in 1);
              \draw (nand2.out) -| (nand3.in 2);
              \draw let \p1 = (nand3.out) in (\x1, \y1) -- ++(0.5, 0) node[right] {Y};
          \end{circuitikz}
      \end{document}
      ```

      <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-21-CONVERT_2.png" alt="DGCR-2-21-CONVERT_2.png" style="zoom:50%;" />

      转换为逻辑函数式：$ Y = \overline{\overline{\overline{A} B} · \overline{A \overline{B}}} = \overline{A}B + A \overline{B} $

+ 波形图与真值表的互相转换

  + 波形图 ==> 真值表

    + 方法：需要从波形图上找出每个时间段里输入变量与函数输出的取值，然后这些输入、输出取值对应列表，就的道理所求的真值表。

    + 例子：

      波形图：

      ```latex
      \documentclass{article}
      \usepackage{tikz} 
      \usetikzlibrary{arrows.meta}%画箭头用的包
      
      \begin{document}
      \begin{tikzpicture}
          \draw (0,6) node[left] {O};
          \draw[->] (0,6)--(8,6) node[right] {t};
          \draw[->] (0,6)--(0,8) node[left] {A}; %箭头线
          \draw[black] (0, 6.1) 
          -- node[above]{0} (1, 6.1) 
          -- (1, 7.1) 
          -- node[above]{1} (2, 7.1) 
          -- node[above]{1} (3, 7.1)
          -- (3, 6.1)
          -- node[above]{0} (4, 6.1)
          -- (4, 7.1)
          -- node[above]{1} (5, 7.1)
          -- node[above]{1} (6, 7.1)
          -- node[above]{1} (7, 7.1);
      
          \draw (0,3) node[left] {O};
          \draw[->] (0,3)--(8,3) node[right] {t};
          \draw[->] (0,3)--(0,5) node[left] {B}; %箭头线
          \draw[black] (0, 3.1) 
          -- node[above]{0} (1, 3.1) 
          -- (1, 4.1) 
          -- node[above]{1} (2, 4.1) 
          -- (2, 3.1)
          -- node[above]{0} (3, 3.1)
          -- (3, 4.1)
          -- node[above]{1} (4, 4.1)
          -- node[above]{1} (5, 4.1)
          -- (5, 3.1)
          -- node[above]{0} (6, 3.1)
          -- (6, 4.1)
          -- node[above]{1} (7, 4.1);
      
          \draw (0,0) node[left] {O};
          \draw[->] (0,0)--(8,0) node[right] {t};
          \draw[->] (0,0)--(0,2) node[left] {Y}; %箭头线
          \draw[black] (0, 1.1) 
          -- node[above]{1} (1, 1.1) 
          -- (1, 0.1) 
          -- node[above]{0} (2, 0.1) 
          -- (2, 1.1)
          -- node[above]{1} (3, 1.1)
          -- (3, 0.1)
          -- node[above]{0} (4, 0.1)
          -- node[above]{0} (5, 0.1)
          -- (5, 1.1)
          -- node[above]{1} (6, 1.1)
          -- (6, 0.1)
          -- node[above]{0} (7, 0.1);
      \end{tikzpicture}
       
      \end{document} 
      ```

      <img src="https://picgo-storage-typora.oss-cn-shanghai.aliyuncs.com/DGCR-2-22-CONVERT_3.png" alt="DGCR-2-22-CONVERT_3.png" style="zoom:50%;" />

      真值表：

      | A    | B    | Y    |
      | ---- | ---- | ---- |
      | 0    | 0    | 1    |
      | 0    | 1    | 0    |
      | 1    | 0    | 1    |
      | 1    | 1    | 0    |

  + 真值表 ==> 波形图

    + 方法：只需将真值表当中所有的输入变量与对应的输出变量取值一次排列化成以时间为横轴的波形，就得到了所求的波形图。
    + 例子：这里不再进行赘述。

  
